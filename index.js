require('dotenv').config();
const { Client, GatewayIntentBits, Collection, EmbedBuilder } = require('discord.js');
const { GoogleGenerativeAI } = require("@google/generative-ai");
require("./server.js");

const genAI = new GoogleGenerativeAI(process.env.AI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
// Kh·ªüi t·∫°o client v·ªõi c√°c intents c·∫ßn thi·∫øt
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildModeration
  ]
});

// C·∫•u h√¨nh bot
const config = {
  prefix: '!',
  token: process.env.DISCORD_TOKEN, // Thay b·∫±ng token th·ª±c c·ªßa b·∫°n
  modLogChannel: 'mod-logs', // K√™nh ghi nh·∫≠t k√Ω ho·∫°t ƒë·ªông qu·∫£n l√Ω
  mutedRole: 'Muted' // T√™n role cho ng∆∞·ªùi b·ªã mute
};
const SON_ID = '1349637201666768898';
const CAMGIF = 'a:campuchigif:1352142676056735764';
// ƒê·ªëi t∆∞·ª£ng l∆∞u tr·ªØ c·∫£nh c√°o t·∫°m th·ªùi
const warnings = new Collection();

// Kh·ªüi ƒë·ªông bot
client.once('ready', () => {
  console.log(`Bot ƒë√£ s·∫µn s√†ng! ƒêƒÉng nh·∫≠p v·ªõi t√™n ${client.user.tag}`);
  client.user.setActivity('!help ƒë·ªÉ xem l·ªánh', { type: 'WATCHING' });
  
  // ƒê·∫£m b·∫£o m·ªói server c√≥ role Muted
  client.guilds.cache.forEach(guild => {
    let mutedRole = guild.roles.cache.find(role => role.name === config.mutedRole);
    if (!mutedRole) {
      try {
        guild.roles.create({
          name: config.mutedRole,
          permissions: []
        }).then(role => {
          console.log(`ƒê√£ t·∫°o role ${role.name} cho server ${guild.name}`);
          
          // Thi·∫øt l·∫≠p quy·ªÅn cho role Muted trong m·ªói k√™nh
          guild.channels.cache.forEach(channel => {
            channel.permissionOverwrites.create(role, {
              SendMessages: false,
              AddReactions: false,
              Speak: false
            });
          });
        });
      } catch (error) {
        console.error(`Kh√¥ng th·ªÉ t·∫°o role Muted cho server ${guild.name}: ${error}`);
      }
    }
  });
  setInterval(() => {
    const channel = client.channels.cache.get("1349638167812247578");
    if (channel) {
        channel.send(`<@1349637201666768898>, ƒë√£ t·ªõi th·ªùi gian ch√≠ch ƒëi·ªán ƒë·ªãnh k·ª≥, ƒë∆∞a c·ªï ƒë√¢y,<a:campuchigif:1352142676056735764> "r·∫πt r·∫πt r·∫πt ....."`);
    } else {
        console.log('Kh√¥ng t√¨m th·∫•y k√™nh.');
    }
}, 5200000);
});

// X·ª≠ l√Ω tin nh·∫Øn
client.on('messageCreate', async message => {
  // B·ªè qua tin nh·∫Øn t·ª´ bot v√† tin nh·∫Øn kh√¥ng b·∫Øt ƒë·∫ßu b·∫±ng prefix
  if (message.author.bot || !message.content.startsWith(config.prefix)) return;
  
  const args = message.content.slice(config.prefix.length).trim().split(/ +/);
  const command = args.shift().toLowerCase();
  
  // Ki·ªÉm tra quy·ªÅn admin/mod
  const hasModPerms = message.member.permissions.has('ModerateMembers') || 
                     message.member.permissions.has('Administrator');
  
  // Danh s√°ch l·ªánh
  switch (command) {
    case 'help':
      sendHelpMessage(message);
      break;
      
    case 'kick':
      if (!hasModPerms) return message.reply('B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.');
      if (!args.length) return message.reply('B·∫°n c·∫ßn tag ng∆∞·ªùi d√πng c·∫ßn kick.');
      kickUser(message, args);
      break;
      
    case 'ban':
      if (!hasModPerms) return message.reply('B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.');
      if (!args.length) return message.reply('B·∫°n c·∫ßn tag ng∆∞·ªùi d√πng c·∫ßn ban.');
      banUser(message, args);
      break;
      
    case 'warn':
      if (!hasModPerms) return message.reply('B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.');
      if (!args.length) return message.reply('B·∫°n c·∫ßn tag ng∆∞·ªùi d√πng c·∫ßn c·∫£nh c√°o.');
      warnUser(message, args);
      break;
      
    case 'mute':
      if (!hasModPerms) return message.reply('B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.');
      if (!args.length) return message.reply('B·∫°n c·∫ßn tag ng∆∞·ªùi d√πng c·∫ßn mute.');
      muteUser(message, args);
      break;
      
    case 'unmute':
      if (!hasModPerms) return message.reply('B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.');
      if (!args.length) return message.reply('B·∫°n c·∫ßn tag ng∆∞·ªùi d√πng c·∫ßn unmute.');
      unmuteUser(message, args);
      break;
      
    case 'purge':
      if (!hasModPerms) return message.reply('B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.');
      if (!args.length) return message.reply('B·∫°n c·∫ßn ch·ªâ ƒë·ªãnh s·ªë l∆∞·ª£ng tin nh·∫Øn c·∫ßn x√≥a.');
      purgeMessages(message, args);
      break;
      
    case 'info':
      if (!args.length) {
        return message.reply('B·∫°n c·∫ßn tag ng∆∞·ªùi d√πng ho·∫∑c nh·∫≠p ID ƒë·ªÉ xem th√¥ng tin.');
      }
      getUserInfo(message, args);
      break;
    case 'campuchia':
      campuchia(message);
      break;
    case 'test1':
      message.reply('t√¥i c√≤n s·ªëng!');
      break;
    case 'ai':
      if (!args.length) return message.reply('B·∫°n c·∫ßn nh·∫≠p n·ªôi dung ƒë·ªÉ g·ªçi AI.');
      try {
        const prompt = args.join(' ');
        const result = await model.generateContent(prompt);
        let content = result.response.text();
        const embedList = [];
        while (content.length > 0) {
            const part = content.substring(0, 2000); // C·∫Øt th√†nh t·ª´ng ph·∫ßn 2000 k√Ω t·ª±
            content = content.substring(2000);

            const embed = new EmbedBuilder()
                .setColor("#ff0000")
                .setAuthor({ name: message.author.username, iconURL: message.author.displayAvatarURL() })
                .setDescription(part);

            embedList.push(embed);
        }

        for (const embed of embedList) {
            await message.channel.send({ embeds: [embed] });
        }
        const fetchedMessage = await message.channel.messages.fetch(message.id).catch(() => null);
        if (fetchedMessage) {
            await message.delete();
        }
        // message.channel.send(result.response.text());
      } catch (error) {
        console.error(error);
        message.reply('C√≥ l·ªói x·∫£y ra khi g·ªçi AI.');
      }
      break;
    case 'clear':
      const fetchedMessages = await message.channel.messages.fetch({ limit: 100 });
      const botMessages = fetchedMessages.filter(msg => msg.author.id === client.user.id);
      message.channel.bulkDelete(botMessages, true).catch(err => console.error(err));
      message.channel.send('ƒê√£ x√≥a t·∫•t c·∫£ tin nh·∫Øn c·ªßa bot!').then(msg => setTimeout(() => msg.delete(), 3000));
      break;
  }
});

// Ghi log khi th√†nh vi√™n tham gia server
client.on('guildMemberAdd', member => {
  const logChannel = member.guild.channels.cache.find(channel => channel.name === config.modLogChannel);
  if (logChannel) {
    logChannel.send(`üì• **${member.user.tag}** ƒë√£ tham gia server. (ID: ${member.id})`);
  }
  
  // C√≥ th·ªÉ th√™m tin nh·∫Øn ch√†o m·ª´ng ·ªü ƒë√¢y
  // member.guild.systemChannel?.send(`Ch√†o m·ª´ng ${member} ƒë·∫øn v·ªõi server!`);
});

// Ghi log khi th√†nh vi√™n r·ªùi server
client.on('guildMemberRemove', member => {
  const logChannel = member.guild.channels.cache.find(channel => channel.name === config.modLogChannel);
  if (logChannel) {
    logChannel.send(`üì§ **${member.user.tag}** ƒë√£ r·ªùi server. (ID: ${member.id})`);
  }
});

// H√†m x·ª≠ l√Ω c√°c l·ªánh
async function sendHelpMessage(message) {
  const helpText = `
**L·ªánh Qu·∫£n L√Ω Server**
\`${config.prefix}kick @user [l√Ω do]\` - Kick ng∆∞·ªùi d√πng
\`${config.prefix}ban @user [l√Ω do]\` - Ban ng∆∞·ªùi d√πng
\`${config.prefix}warn @user [l√Ω do]\` - C·∫£nh c√°o ng∆∞·ªùi d√πng
\`${config.prefix}mute @user [th·ªùi gian] [l√Ω do]\` - Mute ng∆∞·ªùi d√πng (th·ªùi gian t√≠nh b·∫±ng ph√∫t)
\`${config.prefix}unmute @user\` - Unmute ng∆∞·ªùi d√πng
\`${config.prefix}purge [s·ªë l∆∞·ª£ng]\` - X√≥a s·ªë l∆∞·ª£ng tin nh·∫Øn ch·ªâ ƒë·ªãnh
\`${config.prefix}info @user\` - Xem th√¥ng tin ng∆∞·ªùi d√πng
\`${config.prefix}campuchia @user\` - Ch√≠ch ƒëi·ªán ng∆∞·ªùi d√πng
\`${config.prefix}ai [content]\` - G·ªçi AI
\`${config.prefix}clear\` - X√≥a t·∫•t c·∫£ tin nh·∫Øn c·ªßa bot
\`${config.prefix}test2\` - test
`;
  message.channel.send(helpText);
}

async function kickUser(message, args) {
  const member = message.mentions.members.first();
  if (!member) return message.reply('Kh√¥ng th·ªÉ t√¨m th·∫•y ng∆∞·ªùi d√πng n√†y.');
  
  if (!member.kickable) return message.reply('T√¥i kh√¥ng th·ªÉ kick ng∆∞·ªùi d√πng n√†y.');
  
  const reason = args.slice(1).join(' ') || 'Kh√¥ng c√≥ l√Ω do';
  
  try {
    await member.kick(reason);
    message.channel.send(`‚úÖ ƒê√£ kick **${member.user.tag}**. L√Ω do: ${reason}`);
    
    // Ghi log
    logModAction(message.guild, 'Kick', message.author, member.user, reason);
  } catch (error) {
    console.error(error);
    message.reply('C√≥ l·ªói x·∫£y ra khi kick ng∆∞·ªùi d√πng.');
  }
}

async function banUser(message, args) {
  const member = message.mentions.members.first();
  if (!member) return message.reply('Kh√¥ng th·ªÉ t√¨m th·∫•y ng∆∞·ªùi d√πng n√†y.');
  
  if (!member.bannable) return message.reply('T√¥i kh√¥ng th·ªÉ ban ng∆∞·ªùi d√πng n√†y.');
  
  const reason = args.slice(1).join(' ') || 'Kh√¥ng c√≥ l√Ω do';
  
  try {
    await member.ban({ reason });
    message.channel.send(`üî® ƒê√£ ban **${member.user.tag}**. L√Ω do: ${reason}`);
    
    // Ghi log
    logModAction(message.guild, 'Ban', message.author, member.user, reason);
  } catch (error) {
    console.error(error);
    message.reply('C√≥ l·ªói x·∫£y ra khi ban ng∆∞·ªùi d√πng.');
  }
}

async function warnUser(message, args) {
  const member = message.mentions.members.first();
  if (!member) return message.reply('Kh√¥ng th·ªÉ t√¨m th·∫•y ng∆∞·ªùi d√πng n√†y.');
  
  const reason = args.slice(1).join(' ') || 'Kh√¥ng c√≥ l√Ω do';
  
  // L∆∞u c·∫£nh c√°o
  if (!warnings.has(member.id)) {
    warnings.set(member.id, []);
  }
  
  const userWarnings = warnings.get(member.id);
  userWarnings.push({
    moderator: message.author.id,
    reason,
    timestamp: Date.now()
  });
  
  message.channel.send(`‚ö†Ô∏è **${member.user.tag}** ƒë√£ b·ªã c·∫£nh c√°o. **S·ªë c·∫£nh c√°o hi·ªán t·∫°i:** ${userWarnings.length}. L√Ω do: ${reason}`);
  
  // N·∫øu ƒë·ªß 3 c·∫£nh c√°o, t·ª± ƒë·ªông mute
  if (userWarnings.length >= 3) {
    const mutedRole = message.guild.roles.cache.find(role => role.name === config.mutedRole);
    if (mutedRole) {
      await member.roles.add(mutedRole);
      message.channel.send(`üîá **${member.user.tag}** ƒë√£ b·ªã mute t·ª± ƒë·ªông do nh·∫≠n 3 c·∫£nh c√°o.`);
      
      // Ghi log
      logModAction(message.guild, 'Auto-Mute', client.user, member.user, 'Nh·∫≠n 3 c·∫£nh c√°o');
      
      // Reset c·∫£nh c√°o sau khi mute
      warnings.set(member.id, []);
    }
  }
  
  // Ghi log
  logModAction(message.guild, 'C·∫£nh c√°o', message.author, member.user, reason);
}

async function muteUser(message, args) {
  const member = message.mentions.members.first();
  if (!member) return message.reply('Kh√¥ng th·ªÉ t√¨m th·∫•y ng∆∞·ªùi d√πng n√†y.');
  
  // Ki·ªÉm tra s·ªë ph√∫t
  const minutes = parseInt(args[1]);
  if (!minutes || isNaN(minutes)) return message.reply('Vui l√≤ng nh·∫≠p th·ªùi gian mute h·ª£p l·ªá (ph√∫t).');
  
  const reason = args.slice(2).join(' ') || 'Kh√¥ng c√≥ l√Ω do';
  
  const mutedRole = message.guild.roles.cache.find(role => role.name === config.mutedRole);
  if (!mutedRole) return message.reply('Kh√¥ng t√¨m th·∫•y role Muted. Vui l√≤ng t·∫°o role n√†y.');
  
  try {
    await member.roles.add(mutedRole);
    message.channel.send(`üîá ƒê√£ mute **${member.user.tag}** trong **${minutes} ph√∫t**. L√Ω do: ${reason}`);
    
    // Ghi log
    logModAction(message.guild, 'Mute', message.author, member.user, `${minutes} ph√∫t. L√Ω do: ${reason}`);
    
    // T·ª± ƒë·ªông unmute sau kho·∫£ng th·ªùi gian
    setTimeout(async () => {
      if (member.roles.cache.has(mutedRole.id)) {
        await member.roles.remove(mutedRole);
        message.channel.send(`üîä **${member.user.tag}** ƒë√£ ƒë∆∞·ª£c unmute t·ª± ƒë·ªông.`);
        
        // Ghi log
        logModAction(message.guild, 'Auto-Unmute', client.user, member.user, 'H·∫øt th·ªùi gian mute');
      }
    }, minutes * 60000);
  } catch (error) {
    console.error(error);
    message.reply('C√≥ l·ªói x·∫£y ra khi mute ng∆∞·ªùi d√πng.');
  }
}

async function unmuteUser(message, args) {
  const member = message.mentions.members.first();
  if (!member) return message.reply('Kh√¥ng th·ªÉ t√¨m th·∫•y ng∆∞·ªùi d√πng n√†y.');
  
  const mutedRole = message.guild.roles.cache.find(role => role.name === config.mutedRole);
  if (!mutedRole) return message.reply('Kh√¥ng t√¨m th·∫•y role Muted.');
  
  if (!member.roles.cache.has(mutedRole.id)) return message.reply('Ng∆∞·ªùi d√πng n√†y kh√¥ng b·ªã mute.');
  
  try {
    await member.roles.remove(mutedRole);
    message.channel.send(`üîä ƒê√£ unmute **${member.user.tag}**.`);
    
    // Ghi log
    logModAction(message.guild, 'Unmute', message.author, member.user, 'ƒê√£ ƒë∆∞·ª£c g·ª° mute b·ªüi ng∆∞·ªùi qu·∫£n l√Ω');
  } catch (error) {
    console.error(error);
    message.reply('C√≥ l·ªói x·∫£y ra khi unmute ng∆∞·ªùi d√πng.');
  }
}

async function purgeMessages(message, args) {
  const amount = parseInt(args[0]) + 1; // +1 ƒë·ªÉ x√≥a lu√¥n l·ªánh
  
  if (isNaN(amount)) {
    return message.reply('Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.');
  }
  
  if (amount <= 1 || amount > 100) {
    return message.reply('Vui l√≤ng nh·∫≠p s·ªë t·ª´ 1 ƒë·∫øn 99.');
  }
  
  try {
    const deleted = await message.channel.bulkDelete(amount, true);
    message.channel.send(`üóëÔ∏è ƒê√£ x√≥a ${deleted.size - 1} tin nh·∫Øn.`).then(msg => {
      setTimeout(() => msg.delete(), 5000);
    });
    
    // Ghi log
    logModAction(message.guild, 'Purge', message.author, null, `ƒê√£ x√≥a ${deleted.size - 1} tin nh·∫Øn trong k√™nh #${message.channel.name}`);
  } catch (error) {
    console.error(error);
    message.reply('C√≥ l·ªói x·∫£y ra khi x√≥a tin nh·∫Øn ho·∫∑c tin nh·∫Øn qu√° c≈© (>14 ng√†y).');
  }
}

async function campuchia(message) {
    const member = message.mentions.members.first();
    if (!member) return message.reply('Kh√¥ng th·ªÉ t√¨m th·∫•y ng∆∞·ªùi d√πng n√†y.');
    if (message.author.id === member.id) {
      return message.reply('T·ª± ch√≠ch ƒëi·ªán l√† kh√¥ng sao c·∫£, m√†y x·ª©ng ƒë√°ng b·ªã ch√≠ch ƒëi·ªán.');
    }
    if (message.author.id === SON_ID) {
      return message.reply(`√° √†, m√†y c√≤n ƒë√≤i ch√≠ch ƒëi·ªán ng∆∞·ªùi kh√°c √†, m√†y gi·ªèi qu√° <@${SON_ID}>, <a:campuchigif:1352142676056735764> "r·∫πt r·∫πt r·∫πt ......"`);
    }
    if (member.id !== SON_ID) {
      return message.reply(`xin l·ªói, ·ªü ƒë√¢y ch√∫ng t√¥i ch·ªâ ch√≠ch ƒëi·ªán <@${SON_ID}>, ƒë√∫ng v·∫≠y, ch√≠ch n√≥ <a:campuchigif:1352142676056735764> "r·∫πt r·∫πt r·∫πt ......"`);
    }
    return message.reply(`√° √†, th·∫±ng n√†y m√†y x·ª©ng ƒë√°ng b·ªã ch√≠ch ƒëi·ªán ${member} √†, <a:campuchigif:1352142676056735764> h√™y h√™y, "r·∫πt r·∫πt r·∫πt ......"`);
}

async function getUserInfo(message, args) {
  let user;
  
  if (message.mentions.users.size) {
    user = message.mentions.users.first();
  } else if (args[0]) {
    try {
      user = await client.users.fetch(args[0]);
    } catch (error) {
      return message.reply('Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi ID n√†y.');
    }
  }
  
  if (!user) return message.reply('Kh√¥ng th·ªÉ t√¨m th·∫•y ng∆∞·ªùi d√πng.');
  
  const member = message.guild.members.cache.get(user.id);
  
  let infoText = `
**Th√¥ng tin ng∆∞·ªùi d√πng: ${user.tag}**
ID: ${user.id}
T·∫°o t√†i kho·∫£n: ${new Date(user.createdAt).toLocaleString()}
Avatar: ${user.displayAvatarURL({ dynamic: true })}
`;

  if (member) {
    infoText += `
**Th√¥ng tin th√†nh vi√™n Server:**
Bi·ªát danh: ${member.nickname || 'Kh√¥ng c√≥'}
Tham gia server: ${new Date(member.joinedAt).toLocaleString()}
Vai tr√≤: ${member.roles.cache.map(r => r.name).join(', ')}
`;
  }
  
  // Hi·ªÉn th·ªã c·∫£nh c√°o n·∫øu c√≥
  if (warnings.has(user.id)) {
    const userWarnings = warnings.get(user.id);
    infoText += `\n**C·∫£nh c√°o:** ${userWarnings.length}`;
    
    userWarnings.forEach((warn, index) => {
      const moderator = client.users.cache.get(warn.moderator);
      infoText += `\n${index + 1}. B·ªüi: ${moderator ? moderator.tag : 'Unknown'} - ${new Date(warn.timestamp).toLocaleString()} - ${warn.reason}`;
    });
  }
  
  message.channel.send(infoText);
}

// H√†m ghi log h√†nh ƒë·ªông qu·∫£n l√Ω
function logModAction(guild, action, moderator, target, reason) {
  const logChannel = guild.channels.cache.find(channel => channel.name === config.modLogChannel);
  if (!logChannel) return;
  
  let logMessage = `**${action}** | ${new Date().toLocaleString()}\n`;
  logMessage += `**Ng∆∞·ªùi qu·∫£n l√Ω:** ${moderator.tag} (${moderator.id})\n`;
  
  if (target) {
    logMessage += `**Ng∆∞·ªùi d√πng:** ${target.tag} (${target.id})\n`;
  }
  
  logMessage += `**Chi ti·∫øt:** ${reason}`;
  
  logChannel.send(logMessage);
}

// ƒêƒÉng nh·∫≠p v·ªõi token bot
client.login(config.token);